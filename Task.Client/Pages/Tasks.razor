@page "/tasks"
@attribute [Authorize]
@implements IAsyncDisposable
@using Microsoft.AspNetCore.Authorization
@using Task.Client.Pages
@using Task.Client.Services
@using Task.Shared
@inject IJSRuntime JSRuntime
@inject TaskState TaskState
@inject ISnackbar Snackbar
@inject AuthenticationStateProvider AuthStateProvider
@inject IDialogService DialogService

<PageTitle>Drag Board</PageTitle>

<div class="d-flex justify-space-between align-center mb-4">
    <MudText Typo="Typo.h4">Tasks Board</MudText>
    <AuthorizeView Roles="Admin">
        <MudButton Variant="Variant.Filled" Color="Color.Primary" Href="/add-task">Add New Task</MudButton>
    </AuthorizeView>
</div>

@if (_user == null)
{
    <MudProgressCircular Color="Color.Primary" Indeterminate="true" />
}
else
{
    <MudGrid Spacing="3" Class="drag-board-grid">
        @foreach (var status in _workflowStatuses)
        {
            <MudItem xs="12" sm="6" md="4" lg="2">
                <div class="drag-column">
                    <MudText Typo="Typo.h6" Class="drag-column-header">@status.ToString()</MudText>
                    <div class="dropzone" data-status="@status">
                        @foreach (var task in TaskState.Tasks.Where(t => t.Status == status))
                        {
                            var isOwner = _user.Identity?.Name == task.CreatedByEmail;
                            var isAdmin = _user.IsInRole("Admin");

                            if (isOwner || isAdmin)
                            {
                                <div class="drag-card" data-task-id="@task.Id">
                                    <MudCard Elevation="2">
                                        <MudCardHeader>
                                            <CardHeaderContent>
                                                <MudText Typo="Typo.subtitle1">@task.Title</MudText>
                                            </CardHeaderContent>
                                            <CardHeaderActions>
                                                <MudMenu Icon="@Icons.Material.Filled.MoreVert" Dense="true" Size="Size.Small" AnchorOrigin="Origin.BottomRight">
                                                    <MudMenuItem OnClick="() => ShowTaskDetails(task)">View Details</MudMenuItem>
                                                    <AuthorizeView Roles="Admin">
                                                        <MudMenuItem Href="@($"edit-task/{task.Id}")">Edit</MudMenuItem>
                                                        <MudMenuItem OnClick="() => DeleteTask(task.Id)" Disabled="@_deletingTasks.Contains(task.Id)">Delete</MudMenuItem>
                                                    </AuthorizeView>
                                                </MudMenu>
                                            </CardHeaderActions>
                                        </MudCardHeader>
                                        <MudCardContent>
                                            <MudText Typo="Typo.body2" Class="truncate-text">@task.Description</MudText>
                                            <MudText Typo="Typo.caption" Class="mt-2">Due: @task.DueDate?.ToShortDateString()</MudText>
                                        </MudCardContent>
                                    </MudCard>
                                </div>
                            }
                        }
                    </div>
                </div>
            </MudItem>
        }
    </MudGrid>
}

@code {
    private readonly Shared.TaskStatus[] _workflowStatuses = (Shared.TaskStatus[])Enum.GetValues(typeof(Shared.TaskStatus));
    private DotNetObjectReference<Tasks>? _dotNetHelper;
    private HashSet<Guid> _deletingTasks = new();
    private System.Security.Claims.ClaimsPrincipal? _user;
    private bool _jsInitialized = false; // Flag to ensure JS is only initialized once

    protected override async Task OnInitializedAsync()
    {
        var authState = await AuthStateProvider.GetAuthenticationStateAsync();
        _user = authState.User;

        TaskState.OnChange += StateHasChanged;
        if (TaskState.Tasks.Count == 0)
        {
            await TaskState.InitializeTasksAsync();
        }
    }

    // This updated method fixes the timing issue
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        // Check if the board is ready and if our JS script hasn't been run yet
        if (!_jsInitialized && _user != null && TaskState.Tasks.Any())
        {
            _jsInitialized = true; // Mark as initialized
            _dotNetHelper = DotNetObjectReference.Create(this);
            await JSRuntime.InvokeVoidAsync("initializeDragBoard", _dotNetHelper);
        }
    }

    private void ShowTaskDetails(TaskItemDto task)
    {
        var parameters = new DialogParameters { ["Task"] = task };
        var options = new DialogOptions { MaxWidth = MaxWidth.Medium, FullWidth = true };
        DialogService.Show<TaskDetailDialog>(task.Title, parameters, options);
    }

    [JSInvokable]
    public async Task OnTaskDropped(string taskId, string newStatusStr)
    {
        var task = TaskState.Tasks.FirstOrDefault(t => t.Id.ToString() == taskId);
        if (task == null || !Enum.TryParse<Shared.TaskStatus>(newStatusStr, out var newStatus) || task.Status == newStatus) return;

        var isOwner = _user.Identity?.Name == task.CreatedByEmail;
        var isAdmin = _user.IsInRole("Admin");

        if (!isOwner && !isAdmin)
        {
            Snackbar.Add("You can only move your own tasks.", Severity.Error);
            return;
        }

        try
        {
            // Optimistically update the UI first for a smoother experience
            var oldStatus = task.Status;
            task.Status = newStatus;
            StateHasChanged();

            await TaskState.UpdateTaskStatusAsync(task.Id, newStatus);
            Snackbar.Add($"Task '{task.Title}' moved to {newStatus}", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error moving task: {ex.Message}", Severity.Error);
        }
    }

    private async Task DeleteTask(Guid taskId)
    {
        _deletingTasks.Add(taskId);
        try
        {
            await TaskState.DeleteTaskAsync(taskId);
            Snackbar.Add("Task deleted successfully!", Severity.Success);
        }
        catch (Exception ex)
        {
            Snackbar.Add($"Error deleting task: {ex.Message}", Severity.Error);
        }
        finally
        {
            _deletingTasks.Remove(taskId);
        }
    }

    public async ValueTask DisposeAsync()
    {
        TaskState.OnChange -= StateHasChanged;
        if (_dotNetHelper != null)
        {
            _dotNetHelper.Dispose();
        }
    }
}